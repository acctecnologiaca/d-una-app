import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:supabase_flutter/supabase_flutter.dart';
import '../../data/repositories/auth_repository.dart';

// Simple class to hold registration data
class RegisterState {
  final String email;
  final String firstName;
  final String lastName;
  final String password;
  // Add other fields as needed based on the 7 steps

  final String? primaryOccupationId;
  final List<String> secondaryOccupationIds;
  final bool isLoading;
  final String? error;

  const RegisterState({
    this.email = '',
    this.password = '',
    this.firstName = '',
    this.lastName = '',
    this.primaryOccupationId,
    this.secondaryOccupationIds = const [],
    this.isLoading = false,
    this.error,
  });

  RegisterState copyWith({
    String? email,
    String? password,
    String? firstName,
    String? lastName,
    String? primaryOccupationId,
    List<String>? secondaryOccupationIds,
    bool? isLoading,
    String? error,
  }) {
    return RegisterState(
      email: email ?? this.email,
      password: password ?? this.password,
      firstName: firstName ?? this.firstName,
      lastName: lastName ?? this.lastName,
      primaryOccupationId: primaryOccupationId ?? this.primaryOccupationId,
      secondaryOccupationIds:
          secondaryOccupationIds ?? this.secondaryOccupationIds,
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
    );
  }
}

// This class will be generated by Riverpod, so we use _$RegisterNotifier
// and the build method.
// For this to work, you need to add `riverpod_generator` to your pubspec.yaml
// and run `flutter pub run build_runner watch --delete-conflicting-outputs`
// Also, the import for riverpod_annotation might be needed:
// import 'package:riverpod_annotation/riverpod_annotation.dart';
// part 'register_provider.g.dart'; // Assuming this file is named register_provider.dart

// @riverpod
final authRepositoryProvider = Provider<AuthRepository>((ref) {
  return SupabaseAuthRepository(Supabase.instance.client);
});

final registerProvider = StateNotifierProvider<RegisterNotifier, RegisterState>(
  (ref) {
    final authRepo = ref.watch(authRepositoryProvider);
    return RegisterNotifier(authRepo);
  },
);

class RegisterNotifier extends StateNotifier<RegisterState> {
  final AuthRepository _authRepository;

  RegisterNotifier(this._authRepository) : super(const RegisterState());

  void updateEmail(String email) {
    state = state.copyWith(email: email);
  }

  void updateName({String? firstName, String? lastName}) {
    state = state.copyWith(firstName: firstName, lastName: lastName);
  }

  void updatePassword(String password) {
    state = state.copyWith(password: password);
  }

  void updateOccupations({String? primaryId, List<String>? secondaryIds}) {
    state = state.copyWith(
      primaryOccupationId: primaryId,
      secondaryOccupationIds: secondaryIds,
    );
  }

  Future<void> signUp() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _authRepository.signUp(
        email: state.email,
        password: state.password,
        data: {
          'first_name': state.firstName,
          'last_name': state.lastName,
          'occupation_id': state.primaryOccupationId,
          'secondary_occupation_ids': state.secondaryOccupationIds,
        },
      );
      // Success: OTP sent by Supabase
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    } finally {
      state = state.copyWith(isLoading: false);
    }
  }

  Future<void> verifyCode(String code) async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _authRepository.verifyOtp(email: state.email, token: code);
      // Success
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    } finally {
      state = state.copyWith(isLoading: false);
    }
  }

  Future<void> resendCode() async {
    state = state.copyWith(isLoading: true, error: null);
    try {
      await _authRepository.resendOtp(email: state.email);
    } catch (e) {
      state = state.copyWith(error: e.toString());
      rethrow;
    } finally {
      state = state.copyWith(isLoading: false);
    }
  }
}
